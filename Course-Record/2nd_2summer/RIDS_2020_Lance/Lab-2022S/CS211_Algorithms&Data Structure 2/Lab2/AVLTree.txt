package edu.dapeng.dsa.lab2;

public class SpecialAVLTree {
	private Node root;

	private class Node {
		private int key;
		private String value;
		Node leftChild, rightChild;
		int height;

		public Node(int key, String value) {
			this.key = key;
			this.value = value;
		}
	}

	private int height(Node node) {
		return node == null ? -1 : node.height;
	}

	private Node rotateWithLeftChild(Node k2) {
		Node k1 = k2.leftChild;
		k2.leftChild = k1.rightChild;
		k1.rightChild = k2;
		k2.height = Math.max(height(k2.leftChild), height(k2.rightChild)) + 1;
		k1.height = Math.max(height(k1.leftChild), k2.height) + 1;

		return k1;
	}

	private Node rotateWithRightChild(Node k2) {
		Node k1 = k2.rightChild;
		k2.rightChild = k1.leftChild;
		k1.leftChild = k2;
		k2.height = Math.max(height(k2.leftChild), height(k2.rightChild)) + 1;
		k1.height = Math.max(height(k1.rightChild), k2.height) + 1;

		return k1;
	}

	private Node doubleWithLeftChildRightSubtree(Node k3) {
		k3.leftChild = rotateWithRightChild(k3.leftChild);
		return rotateWithLeftChild(k3);
	}

	private Node doubleWithRightChildLeftSubtree(Node k3) {
		k3.rightChild = rotateWithLeftChild(k3.rightChild);
		return rotateWithRightChild(k3);
	}

	private Node balance(Node node) {
		if (node == null)
			return node;

		if (height(node.leftChild) - height(node.rightChild) > 1) {
			if (height(node.leftChild.leftChild) >= height(node.leftChild.rightChild)) {
				node = rotateWithLeftChild(node);
			} else {
				node = doubleWithLeftChildRightSubtree(node);
			}
		} else if (height(node.rightChild) - height(node.leftChild) > 1) {
			if (height(node.rightChild.rightChild) >= height(node.rightChild.leftChild)) {
				node = rotateWithRightChild(node);
			} else {
				node = doubleWithRightChildLeftSubtree(node);
			}
		}

		node.height = Math.max(height(node.leftChild), height(node.rightChild)) + 1;
		return node;
	}

	private Node insert(int key, String value, Node currentRoot) {
		if (currentRoot == null)
			return new Node(key, value);

		if (key < currentRoot.key) {
			currentRoot.leftChild = insert(key, value, currentRoot.leftChild);
		} else if (key > currentRoot.key) {
			currentRoot.rightChild = insert(key, value, currentRoot.rightChild);
		}

		return balance(currentRoot);
	}

	public void insert(int key, String value) {
		root = insert(key, value, root);
	}

	public void remove(int key) {
		root = remove(key, root);
	}

	private Node remove(int toBeRemoved, Node currentRoot) {
		if (currentRoot == null)
			return currentRoot;

		if (toBeRemoved < currentRoot.key) {
			currentRoot.leftChild = remove(toBeRemoved, currentRoot.leftChild);
		} else if (toBeRemoved > currentRoot.key) {
			currentRoot.rightChild = remove(toBeRemoved, currentRoot.rightChild);
		} else if (currentRoot.leftChild != null && currentRoot.rightChild != null) {
			currentRoot.key = findMin(currentRoot.rightChild).key;
			currentRoot.rightChild = remove(currentRoot.key, currentRoot.rightChild);
		} else {
			currentRoot = (currentRoot.leftChild != null) ? currentRoot.leftChild : currentRoot.rightChild;
		}

		return balance(currentRoot);
	}

	private Node findMin(Node currentRoot) {
		if (currentRoot == null)
			return currentRoot;

		while (currentRoot.leftChild != null)
			currentRoot = currentRoot.leftChild;

		return currentRoot;
	}

	public static void main(String[] args) {

	}

}